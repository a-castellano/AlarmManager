
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config_reader: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/a-castellano/AlarmManager/config_reader/read_config.go (96.1%)</option>
				
				<option value="file1">github.com/a-castellano/AlarmManager/device_manager/device_manager.go (25.5%)</option>
				
				<option value="file2">github.com/a-castellano/AlarmManager/tuyadevice/crypto.go (100.0%)</option>
				
				<option value="file3">github.com/a-castellano/AlarmManager/tuyadevice/header.go (68.8%)</option>
				
				<option value="file4">github.com/a-castellano/AlarmManager/tuyadevice/signature.go (100.0%)</option>
				
				<option value="file5">github.com/a-castellano/AlarmManager/tuyadevice/tuyadevice.go (86.4%)</option>
				
				<option value="file6">github.com/a-castellano/AlarmManager/tuyadevice/url.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package config

import (
        "errors"
        "reflect"

        viperLib "github.com/spf13/viper"
)

type TuyaDeviceConfig struct {
        Name       string
        DeviceType string
        Host       string
        ClientID   string
        Secret     string
        DeviceID   string
}

type Config struct {
        Devices map[string]TuyaDeviceConfig
}

func ReadConfig() (Config, error) <span class="cov5" title="6">{
        var configFileLocation string
        var config Config

        var envVariable string = "ALARM_MANAGER_CONFIG_FILE_LOCATION"

        requiredVariables := []string{"tuya_devices"}

        tuyaDevicesRequiredVariables := []string{"name", "type", "host", "client_id", "secret", "device_id"}

        viper := viperLib.New()

        //Look for config file location defined as env var
        viper.BindEnv(envVariable)
        configFileLocation = viper.GetString(envVariable)
        if configFileLocation == "" </span><span class="cov1" title="1">{
                // Get config file from default location
                return config, errors.New(errors.New("Environment variable ALARM_MANAGER_CONFIG_FILE_LOCATION is not defined.").Error())
        }</span>
        <span class="cov4" title="5">viper.SetConfigName("config")
        viper.SetConfigType("toml")
        viper.AddConfigPath(configFileLocation)

        if err := viper.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                return config, errors.New(errors.New("Fatal error reading config file: ").Error() + err.Error())
        }</span>

        <span class="cov4" title="5">for _, requiredVariable := range requiredVariables </span><span class="cov4" title="5">{
                if !viper.IsSet(requiredVariable) </span><span class="cov1" title="1">{
                        return config, errors.New("Fatal error config: no " + requiredVariable + " field was found.")
                }</span>
        }

        <span class="cov4" title="4">devices := make(map[string]TuyaDeviceConfig)
        deviceIDs := make(map[string]bool)
        deviceNames := make(map[string]bool)
        readedDevices := viper.GetStringMap("tuya_devices")

        for deviceKey, deviceInfo := range readedDevices </span><span class="cov5" title="7">{
                deviceInfoValue := reflect.ValueOf(deviceInfo)
                if deviceInfoValue.Kind() != reflect.Map </span><span class="cov0" title="0">{
                        return config, errors.New("Fatal error config: device " + deviceKey + " not a map.")
                }</span> else<span class="cov5" title="7"> {

                        deviceInfoValueMap := deviceInfoValue.Interface().(map[string]interface{})
                        var device TuyaDeviceConfig

                        keys := make(map[string]bool)
                        for key_name := range deviceInfoValueMap </span><span class="cov10" title="41">{
                                keys[key_name] = true
                        }</span>

                        <span class="cov5" title="7">for _, requiredDeviceKey := range tuyaDevicesRequiredVariables </span><span class="cov9" title="32">{
                                if _, ok := keys[requiredDeviceKey]; !ok </span><span class="cov1" title="1">{
                                        return config, errors.New("Fatal error config: device " + deviceKey + " has no " + requiredDeviceKey + ".")
                                }</span> else<span class="cov9" title="31"> {
                                        value := reflect.ValueOf(deviceInfoValueMap[requiredDeviceKey]).Interface().(string)
                                        switch requiredDeviceKey </span>{
                                        case "name":<span class="cov5" title="6">
                                                if _, ok := deviceNames[value]; ok </span><span class="cov1" title="1">{
                                                        return config, errors.New("Fatal error config: device name '" + value + "' is repeated.")
                                                }</span>
                                                <span class="cov4" title="5">device.Name = value</span>
                                        case "type":<span class="cov4" title="5">
                                                device.DeviceType = value</span>
                                        case "host":<span class="cov4" title="5">
                                                device.Host = value</span>
                                        case "client_id":<span class="cov4" title="5">
                                                device.ClientID = value</span>
                                        case "secret":<span class="cov4" title="5">
                                                device.Secret = value</span>
                                        case "device_id":<span class="cov4" title="5">
                                                if _, ok := deviceIDs[value]; ok </span><span class="cov1" title="1">{
                                                        return config, errors.New("Fatal error config: device ID " + value + " is repeated.")
                                                }</span>
                                                <span class="cov4" title="4">device.DeviceID = value</span>
                                        }

                                }
                        }

                        <span class="cov4" title="4">deviceNames[device.Name] = true
                        deviceIDs[device.DeviceID] = true
                        devices[device.Name] = device</span>
                }
        }
        <span class="cov1" title="1">config.Devices = devices
        return config, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package devices

import (
        "encoding/json"
        "errors"
        "fmt"
        "log"
        "net/http"

        config "github.com/a-castellano/AlarmManager/config_reader"
        tuyadevice "github.com/a-castellano/AlarmManager/tuyadevice"
)

type AlarmMode int

const (
        FullyArmed AlarmMode = iota + 1
        Disarmed             // disarmed
        HomeArmed            // home
        Sos                  // sos
        Unknown
)

type AlarmInfo struct {
        IP        string
        LocalKey  string
        Latitude  float32
        Longitude float32
        Name      string
        Mode      AlarmMode
        Online    bool
        Firing    bool
}

type Alarm interface {
        ShowInfo() AlarmInfo
}

type Alarm99ASTResult struct {
        ActiveTime  int     `json:"active_time"`
        BizTime     int     `json:"biz_type"`
        Category    string  `json:"category"`
        CreateTime  int     `json:"create_time"`
        Icon        string  `json:"icon"`
        ID          string  `json:"id"`
        IP          string  `json:"ip"`
        Latitude    float32 `json:"lat,string"`
        Longitude   float32 `json:"lon,string"`
        LocalKey    string  `json:"local_key"`
        Model       string  `json:"model"`
        Name        string  `json:"name"`
        Online      bool    `json:"online"`
        OwnerID     int     `json:"owner_id,string"`
        ProductID   string  `json:"product_id"`
        ProductName string  `json:"product_name"`
        Sub         bool    `json:"sub"`
        TimeZone    string  `json:"time_zone"`
        UID         string  `json:"uid"`
        UpdateTime  int     `json:"update_time"`
        UUID        string  `json:"uuid"`
        Status      []struct {
                Code  string      `json:"code"`
                Value interface{} `json:"value"`
        } `json:"status"`
}

type Alarm99AST struct {
        Result    Alarm99ASTResult `json:"result"`
        Success   bool             `json:"success"`
        Time      int              `json:"t"`
        AlarmInfo AlarmInfo
}

func (a Alarm99AST) ShowInfo() AlarmInfo <span class="cov0" title="0">{
        return a.AlarmInfo
}</span>

type DeviceManager struct {
        initiated   bool
        DevicesInfo map[string]tuyadevice.Device
        AlarmsInfo  map[string]Alarm
}

func CreateTuyaDeviceFromConfig(deviceConfig config.TuyaDeviceConfig) tuyadevice.TuyaDevice <span class="cov1" title="1">{

        device := tuyadevice.TuyaDevice{Name: deviceConfig.Name, DeviceType: deviceConfig.DeviceType, Host: deviceConfig.Host, ClientID: deviceConfig.ClientID, Secret: deviceConfig.Secret, DeviceID: deviceConfig.DeviceID}

        return device
}</span>

func (manager *DeviceManager) AddDevice(device tuyadevice.Device) error <span class="cov10" title="5">{
        deviceName := device.GetDeviceName()
        if _, ok := manager.DevicesInfo[deviceName]; ok </span><span class="cov1" title="1">{
                return fmt.Errorf("Device called '%s' hasalready been added to device manager.", deviceName)
        }</span> else<span class="cov8" title="4"> {
                manager.DevicesInfo[deviceName] = device
        }</span>
        <span class="cov8" title="4">return nil</span>
}

func (manager *DeviceManager) Start(client http.Client) error <span class="cov4" title="2">{
        for deviceName, device := range manager.DevicesInfo </span><span class="cov4" title="2">{
                // Retrieve info foreach device
                tokenError := device.RetrieveToken(client)
                if tokenError != nil </span><span class="cov1" title="1">{
                        return tokenError
                }</span>
                <span class="cov1" title="1">manager.DevicesInfo[deviceName] = device</span>

        }
        <span class="cov1" title="1">return nil</span>
}

func (manager *DeviceManager) RetrieveInfo(client http.Client) error <span class="cov0" title="0">{

        for deviceName, device := range manager.DevicesInfo </span><span class="cov0" title="0">{
                log.Println("Retrieving info from device ", deviceName)
                deviceInfo, deviceInfoErr := device.GetDeviceInfo(client)
                log.Println(string(deviceInfo))
                if deviceInfoErr != nil </span><span class="cov0" title="0">{
                        log.Println("Fatal error retrieving info from device ", deviceName)
                        return deviceInfoErr
                }</span>
                <span class="cov0" title="0">switch device.GetDeviceType() </span>{
                case "99AST":<span class="cov0" title="0">
                        alarmInfo := Alarm99AST{}
                        if unmarshalErr := json.Unmarshal(deviceInfo, &amp;alarmInfo); unmarshalErr != nil </span><span class="cov0" title="0">{
                                return unmarshalErr
                        }</span>
                        // Retrieve Alarm Info
                        <span class="cov0" title="0">alarmInfo.AlarmInfo.IP = alarmInfo.Result.IP
                        alarmInfo.AlarmInfo.LocalKey = alarmInfo.Result.LocalKey
                        alarmInfo.AlarmInfo.Latitude = alarmInfo.Result.Latitude
                        alarmInfo.AlarmInfo.Longitude = alarmInfo.Result.Longitude
                        alarmInfo.AlarmInfo.Online = alarmInfo.Result.Online
                        // Check master mode value
                        var masterStateSet, masterModeSet bool
                        for _, statusTuple := range alarmInfo.Result.Status </span><span class="cov0" title="0">{
                                if masterStateSet &amp;&amp; masterModeSet </span><span class="cov0" title="0">{
                                        break</span>
                                } else<span class="cov0" title="0"> {
                                        switch statusTuple.Code </span>{
                                        case "master_mode":<span class="cov0" title="0">
                                                masterModeValue := fmt.Sprintf("%v", statusTuple.Value)
                                                switch masterModeValue </span>{
                                                case "home":<span class="cov0" title="0">
                                                        alarmInfo.AlarmInfo.Mode = HomeArmed</span>
                                                case "disarmed":<span class="cov0" title="0">
                                                        alarmInfo.AlarmInfo.Mode = Disarmed</span>
                                                case "arm":<span class="cov0" title="0">
                                                        alarmInfo.AlarmInfo.Mode = FullyArmed</span>
                                                case "sos":<span class="cov0" title="0">
                                                        alarmInfo.AlarmInfo.Mode = Sos</span>
                                                default:<span class="cov0" title="0">
                                                        alarmInfo.AlarmInfo.Mode = Unknown</span>
                                                }
                                                <span class="cov0" title="0">masterModeSet = true</span>
                                        case "master_state":<span class="cov0" title="0">
                                                masterStateValue := fmt.Sprintf("%v", statusTuple.Value)
                                                alarmInfo.AlarmInfo.Firing = masterStateValue == "alarm"
                                                masterStateSet = true</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">manager.AlarmsInfo[deviceName] = alarmInfo</span>
                default:<span class="cov0" title="0">
                        errorString := fmt.Sprintf("Alarm %s type %s not supported", deviceName, device.GetDeviceType())
                        return errors.New(errorString)</span>
                }
        }
        <span class="cov0" title="0">manager.initiated = true
        return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package tuyadevice

import (
        "crypto/hmac"
        "crypto/sha256"
        "encoding/hex"
)

func Sha256(data []byte) string <span class="cov10" title="5">{
        sha256Contain := sha256.New()
        sha256Contain.Write(data)
        return hex.EncodeToString(sha256Contain.Sum(nil))
}</span>

func HmacSha256(message string, secret string) string <span class="cov10" title="5">{
        key := []byte(secret)
        h := hmac.New(sha256.New, key)
        h.Write([]byte(message))
        sha := hex.EncodeToString(h.Sum(nil))
        return sha
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package tuyadevice

import (
        "fmt"
        "net/http"
        "strings"
        "time"
)

func (device TuyaDevice) buildHeader(req *http.Request, body []byte) <span class="cov10" title="5">{
        req.Header.Set("client_id", device.ClientID)
        req.Header.Set("sign_method", "HMAC-SHA256")

        timeStamp := fmt.Sprint(time.Now().UnixNano() / 1e6)
        req.Header.Set("t", timeStamp)

        if device.Token != "" </span><span class="cov1" title="1">{
                req.Header.Set("access_token", device.Token)
        }</span>

        <span class="cov10" title="5">sign := device.buildSign(req, body, timeStamp)
        req.Header.Set("sign", sign)</span>
}

func (device TuyaDevice) getHeaderStr(req *http.Request) string <span class="cov10" title="5">{
        signHeaderKeys := req.Header.Get("Signature-Headers")
        if signHeaderKeys == "" </span><span class="cov10" title="5">{
                return ""
        }</span>
        <span class="cov0" title="0">keys := strings.Split(signHeaderKeys, ":")
        headers := ""
        for _, key := range keys </span><span class="cov0" title="0">{
                headers += key + ":" + req.Header.Get(key) + "\n"
        }</span>
        <span class="cov0" title="0">return headers</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package tuyadevice

import (
        "net/http"
        "strings"
)

func (device TuyaDevice) buildSign(req *http.Request, body []byte, timeStamp string) string <span class="cov10" title="5">{
        headers := device.getHeaderStr(req)
        urlStr := getUrlStr(req)
        contentSha256 := Sha256(body)
        stringToSign := req.Method + "\n" + contentSha256 + "\n" + headers + "\n" + urlStr
        signStr := device.ClientID + device.Token + timeStamp + stringToSign
        sign := strings.ToUpper(HmacSha256(signStr, device.Secret))
        return sign
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package tuyadevice

import (
        "bytes"
        "encoding/json"
        "io/ioutil"
        "log"
        "net/http"
        "time"

        "github.com/asaskevich/govalidator"
)

type TokenResponse struct {
        Result struct {
                AccessToken     string `json:"access_token"`
                TokenExpireTime int    `json:"expire_time"`
                RefreshToken    string `json:"refresh_token"`
                UID             string `json:"uid"`
        } `json:"result"`
        Success bool  `json:"success"`
        T       int64 `json:"t"`
}

type Device interface {
        GetDeviceInfo(http.Client) ([]byte, error)
        RetrieveToken(http.Client) error
        GetDeviceType() string
        GetDeviceName() string
}

type TuyaDevice struct {
        Name            string `valid:"required"`
        DeviceType      string `valid:"required"`
        Host            string `valid:"required"`
        ClientID        string `valid:"required"`
        Secret          string `valid:"required"`
        DeviceID        string `valid:"required"`
        Token           string
        TokenExpireTime int64
        RefreshToken    string
}

func (device *TuyaDevice) GetDeviceType() string <span class="cov0" title="0">{
        return device.DeviceType
}</span>

func (device *TuyaDevice) GetDeviceName() string <span class="cov0" title="0">{
        return device.Name
}</span>

func (device *TuyaDevice) Validate() error <span class="cov6" title="2">{
        _, err := govalidator.ValidateStruct(device)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func (device *TuyaDevice) updateToken(client http.Client) error <span class="cov1" title="1">{

        now := time.Now()
        currentTimestamp := now.Unix()
        log.Println(currentTimestamp)
        log.Println(device.TokenExpireTime)
        log.Println(device.TokenExpireTime - currentTimestamp)
        if device.TokenExpireTime-currentTimestamp &lt; 0 </span><span class="cov1" title="1">{
                log.Println("Device " + device.Name + " token has expired, retrive new token.")
                body := []byte(``)
                req, _ := http.NewRequest("GET", device.Host+"/v1.0/token/"+device.RefreshToken, nil)

                device.buildHeader(req, body)
                resp, err := client.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov1" title="1">defer resp.Body.Close()
                log.Println(resp.Body)
                bs, _ := ioutil.ReadAll(resp.Body)
                ret := TokenResponse{}
                unmarshalErr := json.Unmarshal(bs, &amp;ret)
                if unmarshalErr != nil </span><span class="cov0" title="0">{
                        return unmarshalErr
                }</span>
                <span class="cov1" title="1">log.Println("refresh token GET response:", string(bs))
                device.Token = ret.Result.AccessToken
                now := time.Now() // current local time
                device.TokenExpireTime = now.Unix() + int64(ret.Result.TokenExpireTime)
                device.RefreshToken = ret.Result.RefreshToken
                log.Println("New token expire time: ", device.TokenExpireTime)</span>
        } else<span class="cov0" title="0"> {
                log.Println("Device " + device.Name + " token has not expired yet.")
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func (device *TuyaDevice) RetrieveToken(client http.Client) error <span class="cov10" title="3">{
        if device.TokenExpireTime == 0 </span><span class="cov10" title="3">{ // New token
                body := []byte(``)
                req, _ := http.NewRequest("GET", device.Host+"/v1.0/token?grant_type=1", bytes.NewReader(body))

                device.buildHeader(req, body)
                resp, err := client.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov10" title="3">defer resp.Body.Close()
                bs, _ := ioutil.ReadAll(resp.Body)
                ret := TokenResponse{}
                unmarshalErr := json.Unmarshal(bs, &amp;ret)
                if unmarshalErr != nil </span><span class="cov1" title="1">{
                        return unmarshalErr
                }</span>
                <span class="cov6" title="2">log.Println("token GET response:", string(bs))
                device.Token = ret.Result.AccessToken
                now := time.Now() // current local time
                device.TokenExpireTime = now.Unix() + int64(ret.Result.TokenExpireTime)
                device.RefreshToken = ret.Result.RefreshToken</span>

        } else<span class="cov0" title="0"> {
                // refresh token
                return device.updateToken(client)
        }</span>
        <span class="cov6" title="2">return nil</span>

}

func (device TuyaDevice) GetDeviceInfo(client http.Client) ([]byte, error) <span class="cov1" title="1">{
        method := "GET"
        body := []byte(``)
        req, _ := http.NewRequest(method, device.Host+"/v1.0/devices/"+device.DeviceID, bytes.NewReader(body))

        device.buildHeader(req, body)
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
                return []byte(``), err
        }</span>
        <span class="cov1" title="1">defer resp.Body.Close()
        bs, _ := ioutil.ReadAll(resp.Body)

        log.Println("resp:", string(bs))
        return bs, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package tuyadevice

import (
        "net/http"
        "sort"
)

func getUrlStr(req *http.Request) string <span class="cov10" title="5">{
        url := req.URL.Path
        keys := make([]string, 0, 10)

        query := req.URL.Query()
        for key, _ := range query </span><span class="cov7" title="3">{
                keys = append(keys, key)
        }</span>
        <span class="cov10" title="5">if len(keys) &gt; 0 </span><span class="cov7" title="3">{
                url += "?"
                sort.Strings(keys)
                for _, keyName := range keys </span><span class="cov7" title="3">{
                        value := query.Get(keyName)
                        url += keyName + "=" + value + "&amp;"
                }</span>
        }

        <span class="cov10" title="5">if url[len(url)-1] == '&amp;' </span><span class="cov7" title="3">{
                url = url[:len(url)-1]
        }</span>
        <span class="cov10" title="5">return url</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
